% !TEX root = ./docs.tex

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{architecture.png}
    
    \caption{Architektur}
\end{figure}

\author{Matthias Vonend}
\subsection{Chatfunktionalität}
Die Anwendung ist mit einem Thin Client aufgebaut. Damit ein Chat ablaufen kann, muss zunächst eine Verbindung zu einem Server aufgebaut werden.
Dazu wählt der Client zunächst einen zufälligen Server aus und versucht sich zu verbinden.
Wurde eine Verbindung erfolgreich aufgebaut, kann sich der Nutzer mit seinem Nutzernamen und seinem Passwort anmelden.
Sobald der Nutzer angemeldet ist, sendet der Server ihm alle benötigten Informationen inklusive der verpassten
Nachrichten zu. Der Server bergibt jeder eintreffenden Nachricht einen Timestamp, um zu dokumentieren, wann sie erstmalig eingetroffen ist.
Anhand des Timestamps werden die Nachrichten sortiert, damit der Client die korrekte Reihenfolge der Nachrichten darstellen kann.

Wenn ein Client eine Nachricht versenden möchte, wird das Nachrichtenpaket an die Node gesendet, mit der er verbunden ist.
Die Node kümmert sich im Hintergrund darum, die Nachricht an den Zielclient zuzustellen. 
Da alle Nachrichten aus Konsistenzgründen an alle Nodes verteilt werden müssen,
brauchen die Nodes keine Information über die Clients anderer Nodes. Im Falle einer solchen Anforderung
(z.\,B. Abfrage, ob ein anderer Nutzer aktiv ist) könnte ein Protokoll ähnlich zu Routing-Tabellen implementiert werden, um die zusätzliche Funktionalität bereitzustellen.
Empfängt eine Node eine Nachricht, egal ob von einem Client oder von einer anderen Node,
wird überprüft, ob die Nachricht für einen ihr bekannten Client bestimmt war. Wird ein Client gefunden, sendet die Node die Nachricht an den Zielclient.

\author{Jan Grübener, Troy Keßler, Patrick Mischka, Michael Angermeier}
\subsection{Clientfunktionalitäten}
Nach einer erfolgreichen Anmeldung kann der Nutzer zwischen verschiedenen Funktionen auswählen:
% \begin{itemize}
%     \item /help
%     \item /chats
%     \item /contacts
%     \item /createchat
%     \item /openchat
%     \item /exit
% \end{itemize}

\subsubsection*{/help:}
Diese Funktion gibt dem Nutzer einen Überblick über alle möglichen Funktionen, die er aufrufen kann.
Alle Funktionen sind kurz beschrieben, sodass der Nutzer einen Überblick über die Funktionen erhält.

\subsubsection*{/chats:}
Bei einem Aufruf dieser Funktion werden alle Chats, die für den Nutzer zugänglich sind, angezeigt.
%Dafür werden zunächst alle Chats durch die Methode getChats aus der API in einem Set aus Chats gespeichert.
Wenn Chats für den Nutzer verfügbar sind, werden diese in einer Übersicht mit Chatname und teilnehmenden Nutzen dargestellt.
Sind noch keine Chats vorhanden, wird darauf hingewiesen.

\subsubsection*{/contacts:}
Wird \textit{/contacts} aufgerufen, werden alle registrierten Nutzer angezeigt.

\subsubsection*{/createchat:}
Diese Funktion beginnt mit einer Aufforderung an den Nutzer, einen Chatnamen einzugeben.
Danach wird die Anzahl der Teilnehmer für den Chat erfragt, wobei mindestens ein Teilnehmer im Chat enthalten sein muss.
Im nächsten Schritt müssen alle Nutzernamen der Teilnehmer eingetragen werden. 
Jeder Nutzername wird auf seine Gültigkeit geprüft. Ist er ungültig, so wird eine Information darüber ausgegeben (//TODO Määh). 
%Hierfür wird jeder einzelne Nutzername überprüft und
% im Falle eines ungültigen Nutzernamens, wird der Nutzer durch eine Meldung darauf aufmerksam gemacht.
Wurden alle drei Attribute (Chatname, Teilnehmeranzahl, Nutzername der Teilnehmer) erfolgreich eingegeben,
wird ein neuer Chat erstellt.

\subsubsection*{/openchat:}
Will der Nutzer einen Chat öffnen, so muss er zuerst den Chatnamen eingeben. Ist der Chat vorhanden, so wird er geöffnet.
Kann der Chat nicht geöffnet werden, so wird eine Meldung für den Nutzer ausgegeben.
Am Anfang eines Chats wird immer darauf hingewiesen, wie der Chat
verlassen werden kann. Danach werden alle Nachrichten, die in diesem Chat bereits geschrieben wurden, geladen.
Anschließend kann der Nutzer Nachrichten versenden und empfangen.

\subsubsection*{/exit:}
Mithilfe dieser Funktion wird der Nutzer abgemeldet und Client beendet.
\clearpage

\author{Matthias Vonend, Aaron Schweig, Troy Keßler}
\subsection{Fehlerbehandlung}
Um Fehler und Datenverluste zu vermeiden, ist in dem Chatsystem sichergestellt, dass immer mindestens zwei Server (Nodes) \textbf{alle}
Informationen besitzen. So kann während eines Nodeausfalls gewährleistet werden, dass eine Andere alle Aufgaben übernehmen kann.

%Aus den Anforderungen geht hervor, dass es mindestens zwei Server geben muss, die sämtliche Informationen des
%Chatsystems besitzen müssen. Bricht eine Node zusammen, muss eine andere Node dessen Aufgabe übernehmen.
\subsubsection{Client}
Nachdem der Client eingeloggt ist, wartet er kontinuierlich auf neue Pakete vom Server. 



Wird beim Warten ein Fehler geworfen 
bedeutet das, dass diese Node ausgefallen ist. Nun versucht sich die Node wieder zu verbinden. 
Dabei können die Nodes über die Programmargumente eingegeben werden. Wenn sich der Client erfolgreich auf eine andere Node 
verbunden hat loggt er sich automatisch mit den bestehen Usernamen und Passwort ein, sodass der User von dem Ausfall nichts 
mitbekommt. Falls keine von den angegebenen Nodes verfügbar ist, probiert der Client nacheinander auf jede zu verbinden, 
bis eine davon wieder Online ist.

\subsubsection{Server}
Serverseitig können verschiedene Fehler auftretten. Viele Fehler werden bereits durch das TCP-Protokoll verhindert (z.\,B. mehrfach Zustellung, fehlerhafte Übermittlung).
Dennoch können grundsätzlich die folgenden Fehlerfälle eintreten:
\begin{enumerate}
    \item Nachricht des Clients kann nicht korrekt empfangen/gesendet werden\\
        In diesem Fall muss der Server davon ausgehen, dass die Verbindung zusammengebrochen ist und er beendet seine Verbindung. Der Server verlässt sich darauf, dass der Client erneut eine Verbindung aufbaut.
    Alle für den Client relevanten Nachrichten werden dann zu diesem übertragen und der Client muss neue Informationen zurück übertragen.
    \item Nachrichten einer Nachbarnode können nicht korrekt empfangen/gesendet werden\\
        Die Server sind als Peer-to-Peer Server aufgebaut. Demnach muss der Server ähnlich zur Clientverbindung davon ausgehen, dass die Verbindung zusammengebrochen ist.
        Allerdings ist der Server hier selbst dafür zuständig sich erneut zu verbinden. Sämtliche Nachrichten, die an eine Node gesendet werden müssen, werden in einer Queue aufbewahrt und nacheinander gesendet.
        Scheitert die Verbindung, so bleibt die Queue unverändert und wird nach einem erneuten Verbinden weiter abgearbeitet. Es wird solange versucht zu verbinden, bis eine Verbindung zustande gekommen ist.
        Sobald eine Verbindung wieder aufgebaut wurde synchronisieren sich die Nodes, um wieder einen vollständigen Informationsstand zu besitzen. So kommen die Server auch mit Netzwerkpartitionierungen klar. Werden die Server getrennt sind die Clients immer noch in der Lage Nachrichten an ihre jeweiligen Server zu schicken und sobald die Verbindung zwischen den Servern wieder aufgebaut werden konnte gleichen sich diese an.
        Sind keine Nachrichten zu senden, hat die Node keine Möglichkeit festzustellen, ob eine Verbindung noch existiert. Zu diesem Zweck existiert ein Heartbeat, der periodisch die Nachbarnodes anpingt und so prüft, ob die Verbindung noch existiert.
\end{enumerate}
Wie gerade beschrieben führen alle Beteiligten stets eine Synchronisation, wodurch diese immer den kompletten Informationsbestand besitzen. Die Replikationskontrolle wird nach der Write-All-Available Strategie umgesetzt. Ein Client schickt eine Nachricht an einen Server. Der Server versucht alle zu ihm verbundenen Nodes aktuell zu halten indem er die Nachricht oder die Änderung an alle verfügbaren Nodes weiterleitet.

Eine Veränderung des Datenbestandes muss dem entsprechend an alle anderen Nodes weitergegeben werden.
Dadurch sind alle Server gleichwertige.
